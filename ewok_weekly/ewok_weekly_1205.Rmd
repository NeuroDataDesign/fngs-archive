---
title: "ewok_weekly_1205"
author: "Ewok & Tanay"
date: "December 5, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# QC Control

## Plots

![Mean Intensity](sub-0025864_session-1_bold_intens.png)  

![Voxel Histogram](sub-0025864_session-1_bold_voxel_hist.png)  

![Transational](sub-0025864_session-1_bold_trans.png)  

![Rotational](sub-0025864_session-1_bold_rot.png)  

![Displacement](sub-0025864_session-1_bold_disp.png)


## Code
```{r python, eval=FALSE}
# Copyright 2016 NeuroData (http://neurodata.io)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# fmri_qc.py
# Created by Eric W Bridgeford on 2016-06-08.
# Email: ebridge2@jhu.edu

from numpy import ndarray as nar
import numpy as np
from scipy.stats import gaussian_kde
from subprocess import Popen, PIPE
import nibabel as nb
import sys
import re
import random as ran
import scipy.stats.mstats as scim
import os.path
#import matplotlib
#matplotlib.use('Agg')
#import matplotlib.pyplot as plt
import plotly as py
from ndmg.utils import utils as mgu
from ndmg.stats.qc import qc as mgqc
py.tools.set_credentials_file(username='ewalke31', api_key='NI52iUGPhF5VZG3UktR2')

class fmri_qc(object):

    def __init__(self):
        """
        Enables quality control of fMRI and DTI processing pipelines.
        """
        pass


    def stat_summary(self, mri, mri_raw, mri_mc, mask, voxel,
                     aligned_mprage, atlas, title=None, qcdir=None,
                     scanid=None, qc_html=None):
        """
        A function for producing a stat summary page, along with
        an image of all the slices of this mri scan.

        **Outputs:**
            Mean figure:
                - plot for each voxel's mean signal intensity for
              each voxel in the corrected mri's timecourse
            STdev figure:
                - plot of the standard deviation of each voxel's
              corrected timecourse
            SNR figure:
                - plot of signal to noise ratio for each voxel in the
              corrected timecourse
            Slice Wise Intensity figure:
                - averages intensity over slices
                    and plots each slice as a line for corrected mri
                - goal: slice mean signal intensity is approximately same
                  throughout all nvols (lines are relatively flat)
            motion parameters figures (3):
                - 1 figure for rotational, 1 figure for translational motion
                  params, 1 for displacement, calculated with fsl's mcflirt
            stat summary file:
                - provides some useful statistics for analyzing fMRI data;
                  see resources for each individual statistic for the
                  computation

        **Positional Arguments:**
            - mri:
                - the path to a corrected mri scan to analyze
            - mri_raw:
                - the path to an uncorrected mri scan to analyze
            - mri_mc:
                - the motion corrected mri scan.
            - mask:
                - the mask to calculate statistics over.
            - voxel:
                - a matrix for the voxel timeseries.
            - aligned_mprage:
                - the aligned MPRAGE image.
            - atlas:
                - the atlas for alignment.
            - title:
                - the title for the plots (ie, Registered, Resampled, etc)
            - fname:
                - the name to give the file.
        """
        print "Producing Quality Control Summary. \n" +\
            "\tRaw Image: " + mri_raw + "\n" +\
            "\tCorrected Image: " + mri + "\n" +\
            " \tMask: " + mask + "\n"
        cmd = "mkdir -p " + qcdir
        mgu().execute_cmd(cmd)

        mri_im = nb.load(mri)
        mri_dat = mri_im.get_data()
        mri_raw_im = nb.load(mri_raw)

        mprage_dat = nb.load(aligned_mprage).get_data()
        at_dat = nb.load(atlas).get_data()

        print "Opened MRI Images."

        # image for mean signal intensity over time
        mri_datmean = np.nanmean(mri_dat, axis=3)
        mri_datstd = np.nanstd(mri_dat, axis=3)

        # image for slice SNR = mean / stdev
        mri_datsnr = np.divide(mri_datmean, mri_datstd)
        mri_datsnr[np.isnan(mri_datsnr)] = 0

        # image for slice-wise mean intensity
        mri_datmi = np.squeeze(np.apply_over_axes(np.nanmean,
                                                  mri_dat, (0, 1)))
        depth = mri_dat.shape[2]
        nvols = mri_dat.shape[3]

        # max image size is 5x5. after that, reduce size to 5x5
        # with sequences
        depth_seq = np.unique(np.round(np.linspace(0, depth - 1, 25)))
        nrows = int(np.ceil(np.sqrt(depth_seq.shape[0])))
        ncols = int(np.ceil(depth_seq.shape[0]/float(nrows)))

        mri_dat = None  # done with this, so save memory here

        axmean_ref = py.tools.make_subplots(nrows, ncols)
        axmean_anat = py.tools.make_subplots(nrows, ncols)
        axstd = py.tools.make_subplots(nrows, ncols)
        axsnr = py.tools.make_subplots(nrows, ncols)
        axanat_ref = py.tools.make_subplots(nrows, ncols)
        

        fnames = {}
        # produce figures for each slice in the image
        for d in range(0, depth_seq.shape[0]):
            # TODO EB: create nifti image with these values
            # and allow option to add overlap with ref vs mprage
            i = depth_seq[d]
            
           # axmean_ref = fmean_ref.add_subplot(nrows, ncols, d+1)
           # axmean_ref.imshow(mgqc().opaque_colorscale(matplotlib.cm.Blues,
           #                                          mri_datmean[:, :, i]))
            axmean_ref.imshow(mgqc().opaque_colorscale(matplotlib.cm.Reds,
                                                     at_dat[:, :, i]))
           # axmean_ref.set_xlabel('Position (res)')
           # axmean_ref.set_ylabel('Position (res)')
            axmean_ref.set_title('%d slice' % i)

            
            trace1 = py.graph_objs.Heatmap(mgqc().opaque_colorscale(BLUES, mri_datmean[:, :, i]))
            trace2 = py.graph_objs.Heatmap(mgqc().opaque_colorscale(REDS, at_dat[:, :, i]))
            trace = trace1 + trace2
            if ((d+1)%ncols) == 0:
                axmean_ref.append_trace(trace1, int(d/ncols)+1, ncols)
            else:
                axmean_ref.append_trace(trace1, int(d/ncols)+1, (d+1)%ncols)
            axmean_ref['layout']['xaxis'+str(d+1)].update(title='Position (res)')
            axmean_ref['layout']['yaxis'+str(d+1)].update(title='Position (res)')


            

            axmean_anat = fmean_anat.add_subplot(nrows, ncols, d+1)
            axmean_anat.imshow(mgqc().opaque_colorscale(matplotlib.cm.Blues,
                                                      mri_datmean[:, :, i]))
            axmean_anat.imshow(mgqc().opaque_colorscale(matplotlib.cm.Reds,
                                                      mprage_dat[:, :, i]))
            axmean_anat.set_xlabel('Position (res)')
            axmean_anat.set_ylabel('Position (res)')
            axmean_anat.set_title('%d slice' % i)

            axstd = fstd.add_subplot(nrows, ncols, d+1)
            axstd.imshow(mri_datstd[:, :, i], cmap='gray',
                         interpolation='nearest', vmin=0,
                         vmax=np.max(mri_datstd))
            axstd.set_xlabel('Position (res)')
            axstd.set_ylabel('Position (res)')
            axstd.set_title('%d slice' % i)

            axsnr = fsnr.add_subplot(nrows, ncols, d+1)
            axsnr.imshow(mri_datsnr[:, :, i], cmap='gray',
                         interpolation='nearest', vmin=0,
                         vmax=np.max(mri_datsnr))
            axsnr.set_xlabel('Position (res)')
            axsnr.set_ylabel('Position (res)')
            axsnr.set_title('%d slice' % i)

            axanat_ref = fanat_ref.add_subplot(nrows, ncols, d+1)
            axanat_ref.imshow(mgqc().opaque_colorscale(matplotlib.cm.Blues,
                                                     mprage_dat[:, :, i]))
            axanat_ref.set_xlabel('Position (res)')
            axanat_ref.set_ylabel('Position (res)')
            axanat_ref.set_title('%d slice' % i)
            axanat_ref.imshow(mgqc().opaque_colorscale(matplotlib.cm.Reds,
                                                     at_dat[:, :, i]))

        axmi_list = []
        for d in range(0, depth):
            axmi_list.append(py.graph_objs.Scatter(x=range(0,nvols), \
                                                   y=mri_datmi[d, :], mode='lines'))
        layout = dict(title = 'Mean Slice Intensity', \
                      xaxis = dict(title = 'Timepoint', range=[0,nvols]), \
                      yaxis = dict(title = 'Mean Intensity'),
		      showlegend = False)
        axmi = dict(data=axmi_list, layout=layout)
        appended_path = scanid + "_intens.png"
        fnames["intens"] = appended_path
        path = qcdir + "/" + appended_path
        py.plotly.image.save_as(axmi, filename=path)

#        fname = qcdir + "/"
#        axmi.set_xlabel('Timepoint')
#        axmi.set_ylabel('Mean Intensity')
#        axmi.set_title('Mean Slice Intensity')
#        axmi.set_xlim((0, nvols))

#        fhist = plt.figure()
#        axvih = fhist.add_subplot(111)
        nonzero_data = mri_datmean[mri_datmean != 0]
        hist, bins = np.histogram(nonzero_data, bins=500,
                                 range=(0, np.nanmean(nonzero_data) + 
                                        2*np.nanstd(nonzero_data)))
        width = 0.7 * (bins[1] - bins[0])
        center = (bins[:-1] + bins[1:]) / float(2)
#        axvih.bar(center, hist, align='center', width=width)
#        axvih.set_xlabel('Voxel Intensity')
#        axvih.set_ylabel('Number of Voxels')

        axvih = [py.graph_objs.Bar(x=center, y=hist)]
        layout = dict(xaxis = dict(title = 'Voxel Intensity'), \
                      yaxis = dict(title = 'Number of Voxels'))
        fhist = dict(data=axvih, layout=layout)
        appended_path = scanid + "_voxel_hist.png"
        fnames["voxel_hist"] = appended_path
        path = qcdir + "/" + appended_path
        py.plotly.image.save_as(fhist, filename=path)
        
        par_file = mri_mc + ".par"

        abs_pos = np.zeros((nvols, 6))
        rel_pos = np.zeros((nvols, 6))
        with open(par_file) as f:
            counter = 0
            for line in f:
                abs_pos[counter, :] = [float(i) for i in re.split("\\s+",
                                                                  line)[0:6]]
                if counter > 0:
                    rel_pos[counter, :] = np.subtract(abs_pos[counter, :],
                                                      abs_pos[counter-1, :])
                counter += 1


#        ftrans = plt.figure()
#        axtrans = ftrans.add_subplot(111)
#        axtrans.plot(abs_pos[:, 3:6])  # plots the parameters
#        axtrans.set_xlabel('Timepoint')
#        axtrans.set_ylabel('Translation (mm)')
#        axtrans.set_title('Translational Motion Parameters')
#        axtrans.legend(['x', 'y', 'z'])
#        axtrans.set_xlim((0, nvols))
#        ftrans.tight_layout()

        ftrans_list = []
        ftrans_list.append(py.graph_objs.Scatter(x=range(0,nvols),y=abs_pos[:,3], mode='lines', name='x'))
        ftrans_list.append(py.graph_objs.Scatter(x=range(0,nvols),y=abs_pos[:,4], mode='lines', name='y'))
        ftrans_list.append(py.graph_objs.Scatter(x=range(0,nvols),y=abs_pos[:,5], mode='lines', name='z'))
        layout = dict(title = 'Translational Motion Parameters', \
                      xaxis = dict(title = 'Timepoint', range=[0,nvols]), \
                      yaxis = dict(title = 'Translation (mm)'))
        ftrans = dict(data=ftrans_list, layout=layout)
        appended_path = scanid + "_trans.png"
        fnames["trans"] = appended_path
        path = qcdir + "/" + appended_path
        py.plotly.image.save_as(ftrans, filename=path)
        
        
#        frot = plt.figure()
#        axrot = frot.add_subplot(111)
#        axrot.plot(abs_pos[:, 0:3])
#        axrot.set_xlabel('Timepoint')
#        axrot.set_ylabel('Rotation (rad)')
#        axrot.set_title('Rotational Motion Parameters')
#        axrot.legend(['x', 'y', 'z'])
#        axrot.set_xlim((0, nvols))

        frot_list = []
        frot_list.append(py.graph_objs.Scatter(x=range(0,nvols),y=abs_pos[:, 0], mode='lines', name='x'))
        frot_list.append(py.graph_objs.Scatter(x=range(0,nvols),y=abs_pos[:, 1], mode='lines', name='y'))
        frot_list.append(py.graph_objs.Scatter(x=range(0,nvols),y=abs_pos[:, 2], mode='lines', name='z'))
        layout = dict(title = 'Rotational Motion Parameters', \
                      xaxis = dict(title = 'Timepoint', range=[0,nvols]), \
                      yaxis = dict(title = 'Rotation (rad)'))
        frot = dict(data=frot_list, layout=layout)
        appended_path = scanid + "_rot.png"
        fnames["rot"] = appended_path
        path = qcdir + "/" + appended_path
        py.plotly.image.save_as(frot, filename=path)

        trans_abs = np.linalg.norm(abs_pos[:, 3:6], axis=1)
        trans_rel = np.linalg.norm(rel_pos[:, 3:6], axis=1)
        rot_abs = np.linalg.norm(abs_pos[:, 0:3], axis=1)
        rot_rel = np.linalg.norm(rel_pos[:, 0:3], axis=1)
        fmc_list = []
        fmc_list.append(py.graph_objs.Scatter(x=range(0,nvols),y=trans_abs, mode='lines', name='absolute'))
        fmc_list.append(py.graph_objs.Scatter(x=range(0,nvols),y=trans_rel, mode='lines', name='relative'))
        layout = dict(title = 'Estimated Displacement', \
                      xaxis = dict(title = 'Timepoint', range=[0,nvols]), \
                      yaxis = dict(title = 'Movement (mm)'))
        fmc = dict(data=fmc_list, layout=layout)
        appended_path = scanid + "_disp.png"
        fnames["disp"] = appended_path
        path = qcdir + "/" + appended_path
        py.plotly.image.save_as(fmc, filename=path)

#        fmc = plt.figure()
#        axmc = fmc.add_subplot(111)
#        axmc.plot(trans_abs)
#        axmc.plot(trans_rel)
#        axmc.set_xlabel('Timepoint')
#        axmc.set_ylabel('Movement (mm)')
#        axmc.set_title('Estimated Displacement')
#        axmc.legend(['absolute', 'relative'])
#        axmc.set_xlim((0, nvols))

#        figures = {"mean_ref": [fmean_ref, nrows, ncols],
#                   "mean_anat": [fmean_anat,nrows,ncols],
#                   "anat_ref": [fanat_ref,nrows,ncols],
#                   "std": [fstd,nrows,ncols],
#                   "snr": [fsnr,nrows,ncols],
#                   "voxel_hist": [fhist,1,1], "intens": [fmi,1,1], 
#                   "trans": [ftrans,1,1], "rot": [frot,1,1], "disp": [fmc,1,1]}

#        for idx, figlist in figures.items():
#            fig=figlist[0]
#            fig.set_size_inches(figlist[1]*6, figlist[2]*6)
#            fig.tight_layout()
#            appended_path = scanid + "_" + str(idx) + ".png"
#            fnames[idx] = appended_path
#            path = fname + appended_path
#            fig.savefig(path)
       
        fnames['sub'] = scanid

        mgqc().update_template_qc(qc_html, fnames)


        fstat = open(qcdir + "/" + scanid + "_stat_sum.txt", 'w')
        fstat.write("General Information\n")
        fstat.write("Raw Image Resolution: " +
                    str(mri_raw_im.get_header().get_zooms()[0:3]) + "\n")
        fstat.write("Corrected Image Resolution: " +
                    str(mri_im.get_header().get_zooms()[0:3]) + "\n")
        fstat.write("Number of Volumes: %d" % nvols)

        fstat.write("\n\n")
        fstat.write("Signal  Statistics\n")
        fstat.write("Signal Mean: %.4f\n" % np.mean(voxel))
        fstat.write("Signal Stdev: %.4f\n" % np.std(voxel))
        fstat.write("Number of Voxels: %d\n" % voxel.shape[0])
        fstat.write("Average SNR per voxel: %.4f\n" %
                    np.nanmean(np.divide(np.mean(voxel, axis=1),
                               np.std(voxel, axis=1))))
        fstat.write("\n\n")

        # Motion Statistics
        mean_abs = np.mean(abs_pos, axis=0)  # column wise means per param
        std_abs = np.std(abs_pos, axis=0)
        max_abs = np.max(np.abs(abs_pos), axis=0)
        mean_rel = np.mean(rel_pos, axis=0)
        std_rel = np.std(rel_pos, axis=0)
        max_rel = np.max(np.abs(rel_pos), axis=0)
        fstat.write("Motion Statistics\n")

        absrel = ["absolute", "relative"]
        transrot = ["motion", "rotation"]
        list1 = [max(trans_abs), np.mean(trans_abs), np.sum(trans_abs > 1), np.sum(trans_abs > 5), \
                 mean_abs[3], std_abs[3], max_abs[3], mean_abs[4], std_abs[4], max_abs[4], mean_abs[5], \
                 std_abs[5], max_abs[5]]
        list2 = [max(trans_rel), np.mean(trans_rel), np.sum(trans_rel > 1), np.sum(trans_rel > 5), \
                 mean_abs[3], std_rel[3], max_rel[3], mean_abs[4], std_rel[4], max_rel[4], mean_abs[5], \
                 std_rel[5], max_rel[5]]
        list3 = [max(rot_abs), np.mean(rot_abs), 0, 0, mean_abs[0], std_abs[0], max_abs[0], mean_abs[1],\
                 std_abs[1], max_abs[1], mean_abs[2], std_abs[2], max_abs[2]]
        list4 = [max(rot_rel), np.mean(rot_rel), 0, 0, mean_rel[0], std_rel[0], max_rel[0], mean_rel[1],\
                 std_rel[1], max_rel[1], mean_rel[2], std_rel[2], max_rel[2]]
        lists = [list1, list2, list3, list4]
        headinglist = ["Absolute Translational Statistics>>\n", "Relative Translational Statistics>>\n",\
                       "Absolute Rotational Statistics>>\n", "Relative Rotational Statistics>>\n"]
        x = 0
        for motiontype in transrot:
            for measurement in absrel:
                fstat.write(headinglist[x])
                fstat.write("Max " +measurement+" "+motiontype+": %.4f\n" % lists[x][0])
                fstat.write("Mean "+measurement+" "+motiontype+": %.4f\n" % lists[x][1])
                if motiontype == "motion":
                    fstat.write("Number of "+measurement+" "+motiontype+"s > 1mm: %.4f\n" % lists[x][2])
                    fstat.write("Number of "+measurement+" "+motiontype+"s > 5mm: %.4f\n" % lists[x][3])
                fstat.write("Mean "+measurement+" x "+motiontype+": %.4f\n" % lists[x][4])
                fstat.write("Std " +measurement+" x "+motiontype+": %.4f\n" % lists[x][5])
                fstat.write("Max " +measurement+" x "+motiontype+": %.4f\n" % lists[x][6])
                fstat.write("Mean "+measurement+" y "+motiontype+": %.4f\n" % lists[x][7])
                fstat.write("Std " +measurement+" y "+motiontype+": %.4f\n" % lists[x][8])
                fstat.write("Max " +measurement+" y "+motiontype+": %.4f\n" % lists[x][9])
                fstat.write("Mean "+measurement+" z "+motiontype+": %.4f\n" % lists[x][10])
                fstat.write("Std " +measurement+" z "+motiontype+": %.4f\n" % lists[x][11])
                fstat.write("Max " +measurement+" z "+motiontype+": %.4f\n" % lists[x][12])
                x = x + 1

        fstat.close()

```